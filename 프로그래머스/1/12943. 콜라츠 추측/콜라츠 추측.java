/* [문제풀이]
 * long 변환
   입력 num을 long으로 변환 → 이유: 계산 중 n * 3 + 1이 int 범위를 초과할 수 있기 때문
   예: 626331 × 3 + 1 = 1,879,994,
   이후 반복 중 더 커질 수 있음 → int로는 오버플로우 발생 → 잘못된 결과(4881)

 * while 반복
   n != 1이면 계속 변환
   단, 500번 이상 반복하면 즉시 중단 (count < 500 조건)

 * 삼항 연산자
   (n % 2 == 0) ? (n / 2) : (n * 3 + 1)
   → 짝수 / 홀수 처리 로직을 간결하게 표현

 * 결과 반환
   n == 1이면 정상적으로 1이 되었으므로 반복 횟수 count 반환
   500번 넘겨도 1이 안 되면 -1 반환
 */

class Solution {
    
    public int solution(int num) {
        
        // long 타입으로 변환 (계산 중 오버플로우 방지)
        long n = num;      

        int count = 0;  // 반복 횟수 저장 변수

        // n이 1이 될 때까지 반복 (최대 500번까지만)
        while (n != 1 && count < 500) {

            // 짝수인 경우 → 2로 나누기
            // 홀수인 경우 → 3을 곱하고 1을 더하기
            n = (n % 2 == 0) ? (n / 2) : (n * 3 + 1);

            count++; // 반복 횟수 증가
        }

        // 500번 이내에 1이 되면 count 반환, 아니면 -1 반환
        return (n == 1) ? count : -1;
    }
}